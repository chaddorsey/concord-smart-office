<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Concord Frame</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: none;
    }

    #media-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    #media-container img,
    #media-container video {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-family: system-ui, sans-serif;
      text-align: center;
    }

    #loading .spinner {
      width: 50px;
      height: 50px;
      border: 3px solid #333;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #error {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff6b6b;
      font-family: system-ui, sans-serif;
      text-align: center;
      padding: 20px;
    }

    /* Transition effect */
    .fade-out {
      opacity: 0;
      transition: opacity 0.5s ease-out;
    }

    .fade-in {
      opacity: 1;
      transition: opacity 0.5s ease-in;
    }

    /* Debug overlay - hidden by default, show with ?debug=1 */
    #debug {
      display: none;
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 4px;
      max-width: 300px;
    }

    #debug.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div id="media-container">
    <div id="loading">
      <div class="spinner"></div>
      <div>Loading frame...</div>
    </div>
    <div id="error">
      <div>Unable to connect</div>
      <div style="font-size: 14px; margin-top: 10px;">Retrying...</div>
    </div>
  </div>
  <div id="debug"></div>

  <script>
    // Get frame ID from URL path
    const frameId = parseInt(window.location.pathname.split('/').pop(), 10) || 1;
    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.get('debug') === '1';
    const haToken = urlParams.get('token') || localStorage.getItem('ha_token') || '';

    // Store token if provided in URL
    if (urlParams.get('token')) {
      localStorage.setItem('ha_token', urlParams.get('token'));
    }

    const debugEl = document.getElementById('debug');
    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    const containerEl = document.getElementById('media-container');

    if (debugMode) {
      debugEl.classList.add('visible');
    }

    function log(msg) {
      console.log(`[Frame ${frameId}]`, msg);
      if (debugMode) {
        debugEl.textContent = `Frame ${frameId}\n${msg}`;
      }
    }

    let ws = null;
    let wsId = 1;
    let mediaLibrary = [];
    let currentPlaylist = '';
    let currentIndex = 0;
    let currentMediaEl = null;
    let reconnectTimeout = null;
    let haConfig = null;

    // Fetch HA config from our server
    async function fetchConfig() {
      try {
        const res = await fetch('/api/config');
        haConfig = await res.json();
        log(`HA URL: ${haConfig.haUrl}`);
        return true;
      } catch (e) {
        log(`Config fetch failed: ${e.message}`);
        return false;
      }
    }

    // Connect to Home Assistant WebSocket
    async function connectHA() {
      if (!haConfig) {
        const ok = await fetchConfig();
        if (!ok) {
          setTimeout(connectHA, 5000);
          return;
        }
      }

      if (!haToken) {
        log('No HA token. Add ?token=YOUR_TOKEN to URL');
        errorEl.querySelector('div').textContent = 'No token configured';
        errorEl.querySelector('div:last-child').textContent = 'Add ?token=YOUR_HA_TOKEN to URL';
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
        return;
      }

      log('Connecting to HA...');

      try {
        ws = new WebSocket(haConfig.wsUrl);

        ws.onopen = () => {
          log('WebSocket connected');
        };

        ws.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          handleMessage(msg);
        };

        ws.onerror = (err) => {
          log(`WebSocket error: ${err.message || 'Unknown'}`);
        };

        ws.onclose = () => {
          log('WebSocket closed, reconnecting...');
          loadingEl.style.display = 'block';
          errorEl.style.display = 'none';
          clearTimeout(reconnectTimeout);
          reconnectTimeout = setTimeout(connectHA, 3000);
        };
      } catch (e) {
        log(`Connection error: ${e.message}`);
        setTimeout(connectHA, 5000);
      }
    }

    function sendMessage(msg) {
      msg.id = wsId++;
      ws.send(JSON.stringify(msg));
      return msg.id;
    }

    function handleMessage(msg) {
      switch (msg.type) {
        case 'auth_required':
          log('Authenticating...');
          sendMessage({ type: 'auth', access_token: haToken });
          break;

        case 'auth_ok':
          log('Authenticated');
          subscribeToStates();
          fetchInitialState();
          break;

        case 'auth_invalid':
          log('Auth failed: ' + msg.message);
          errorEl.querySelector('div').textContent = 'Authentication failed';
          errorEl.querySelector('div:last-child').textContent = 'Check your token';
          loadingEl.style.display = 'none';
          errorEl.style.display = 'block';
          ws.close();
          break;

        case 'event':
          if (msg.event?.event_type === 'state_changed') {
            handleStateChange(msg.event.data);
          }
          break;

        case 'result':
          if (msg.success && msg.result) {
            handleStatesResult(msg.result);
          }
          break;
      }
    }

    function subscribeToStates() {
      sendMessage({
        type: 'subscribe_events',
        event_type: 'state_changed'
      });
    }

    function fetchInitialState() {
      sendMessage({ type: 'get_states' });
    }

    function handleStatesResult(states) {
      // Find our frame's playlist and index
      const playlistState = states.find(s => s.entity_id === `input_select.frame_${frameId}_playlist`);
      const indexState = states.find(s => s.entity_id === `input_number.frame_${frameId}_index`);
      const libraryState = states.find(s => s.entity_id === 'input_text.media_library');

      if (playlistState) {
        currentPlaylist = playlistState.state;
      }

      if (indexState) {
        currentIndex = parseInt(indexState.state, 10) || 0;
      }

      if (libraryState) {
        try {
          mediaLibrary = JSON.parse(libraryState.state);
        } catch (e) {
          log('Failed to parse media library');
          mediaLibrary = [];
        }
      }

      log(`Playlist: ${currentPlaylist}, Index: ${currentIndex}`);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'none';
      updateDisplay();
    }

    function handleStateChange(data) {
      const entityId = data.entity_id;
      const newState = data.new_state?.state;

      if (entityId === `input_select.frame_${frameId}_playlist`) {
        currentPlaylist = newState;
        currentIndex = 0; // Reset to start of new playlist
        log(`Playlist changed: ${currentPlaylist}`);
        updateDisplay();
      } else if (entityId === `input_number.frame_${frameId}_index`) {
        currentIndex = parseInt(newState, 10) || 0;
        log(`Index changed: ${currentIndex}`);
        updateDisplay();
      } else if (entityId === 'input_text.media_library') {
        try {
          mediaLibrary = JSON.parse(newState);
          log('Media library updated');
          updateDisplay();
        } catch (e) {
          log('Failed to parse updated media library');
        }
      }
    }

    function updateDisplay() {
      // Filter media by current playlist
      const playlistMedia = mediaLibrary.filter(m => m.playlist === currentPlaylist);

      if (playlistMedia.length === 0) {
        log('No media in playlist');
        showPlaceholder();
        return;
      }

      // Get current media (wrap around if index exceeds length)
      const mediaIndex = currentIndex % playlistMedia.length;
      const media = playlistMedia[mediaIndex];

      log(`Showing: ${media.title} (${mediaIndex + 1}/${playlistMedia.length})`);
      showMedia(media);
    }

    function showMedia(media) {
      // Fade out current media
      if (currentMediaEl) {
        currentMediaEl.classList.add('fade-out');
        setTimeout(() => {
          if (currentMediaEl && currentMediaEl.parentNode) {
            currentMediaEl.parentNode.removeChild(currentMediaEl);
          }
        }, 500);
      }

      let el;
      if (media.type === 'video') {
        el = document.createElement('video');
        el.src = media.url;
        el.autoplay = true;
        el.loop = true;
        el.muted = true;
        el.playsInline = true;
      } else {
        el = document.createElement('img');
        el.src = media.url;
        el.alt = media.title || 'Frame media';
      }

      el.style.opacity = '0';
      containerEl.appendChild(el);

      // Trigger fade in after load
      const onLoad = () => {
        el.style.opacity = '1';
        el.classList.add('fade-in');
      };

      if (media.type === 'video') {
        el.oncanplay = onLoad;
      } else {
        el.onload = onLoad;
      }

      el.onerror = () => {
        log(`Failed to load: ${media.url}`);
        el.remove();
        showPlaceholder();
      };

      currentMediaEl = el;
    }

    function showPlaceholder() {
      if (currentMediaEl) {
        currentMediaEl.remove();
        currentMediaEl = null;
      }

      const el = document.createElement('div');
      el.style.cssText = 'color: #666; font-family: system-ui; text-align: center;';
      el.innerHTML = `<div style="font-size: 48px;">Frame ${frameId}</div><div style="margin-top: 10px;">${currentPlaylist || 'No playlist'}</div>`;
      containerEl.appendChild(el);
      currentMediaEl = el;
    }

    // Prevent screen sleep on supported browsers
    async function preventSleep() {
      try {
        if ('wakeLock' in navigator) {
          await navigator.wakeLock.request('screen');
          log('Wake lock acquired');
        }
      } catch (e) {
        log('Wake lock not available');
      }
    }

    // Initialize
    preventSleep();
    connectHA();
  </script>
</body>
</html>
