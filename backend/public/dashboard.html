<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="refresh" content="300">
  <title>Office Dashboard - Concord Consortium</title>
  <!-- Adobe Fonts (Museo & Museo Sans) -->
  <link rel="stylesheet" href="https://use.typekit.net/jzs4ixz.css">
  <style>
    :root {
      --cc-black: #000000;
      --cc-white: #ffffff;
      --cc-gold: #ffc320;
      --cc-cyan: #0693e3;
      --cc-purple: #9b51e0;
      --cc-green: #00d084;
      --cc-orange: #ff6900;
      --cc-gray-light: #f5f5f5;
      --cc-gray: #e0e0e0;
      --cc-gray-dark: #666666;
      /* Museo font families from Adobe Typekit */
      --font-heading: 'museo', Georgia, serif;
      --font-body: 'museo-sans', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: var(--font-body);
      background: var(--cc-white);
      min-height: 100vh;
      color: var(--cc-black);
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: var(--cc-black);
      color: var(--cc-white);
      padding: 1rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-family: var(--font-heading);
      font-size: 1.5rem;
      font-weight: 700;
    }

    .logo span {
      color: var(--cc-gold);
    }

    .time {
      font-size: 2rem;
      font-weight: 300;
    }

    /* Alert Banner */
    .alert-banner {
      display: none;
      background: var(--cc-gold);
      color: var(--cc-black);
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      text-align: center;
      animation: pulse 2s ease-in-out infinite;
    }

    .alert-banner.show { display: block; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    /* Main Grid - Portrait Layout */
    .main-grid {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto auto auto 1fr;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
    }

    /* Panel Styles */
    .panel {
      background: var(--cc-white);
      border: 1px solid var(--cc-gray);
      border-radius: 12px;
      overflow: hidden;
    }

    .panel-header {
      background: var(--cc-gray-light);
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--cc-gray);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .panel-header h2 {
      font-family: var(--font-heading);
      font-size: 0.875rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--cc-gray-dark);
    }

    .panel-content {
      padding: 1rem;
    }

    /* Staff Panel - Full width top */
    .panel-staff {
      grid-column: span 2;
    }

    .staff-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .staff-card {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.6rem 0.8rem;
      border-radius: 10px;
      background: rgba(255, 195, 32, 0.2);
      min-width: 160px;
    }

    .staff-avatar {
      width: 52px;
      height: 52px;
      border-radius: 8px;
      background: rgba(255, 195, 32, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-body);
      font-size: 1.1rem;
      font-weight: 900;
      color: var(--cc-black);
      flex-shrink: 0;
      overflow: hidden;
    }

    .staff-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: top;
    }

    .staff-avatar span {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .staff-info .name {
      font-family: var(--font-body);
      font-weight: 900;
      font-size: 0.95rem;
      color: var(--cc-black);
    }

    .staff-info .time {
      font-family: var(--font-body);
      font-weight: 100;
      font-size: 0.75rem;
      color: rgba(0, 0, 0, 0.6);
    }

    .empty-state {
      color: var(--cc-gray-dark);
      font-style: italic;
      padding: 1rem;
    }

    /* Check-in Panel */
    .panel-checkin {
      display: flex;
      flex-direction: column;
    }

    .panel-checkin .panel-header {
      background: var(--cc-gold);
    }

    .panel-checkin .panel-header h2 {
      color: var(--cc-black);
    }

    .qr-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
    }

    #qrcode {
      background: white;
      padding: 0.5rem;
      border-radius: 8px;
    }

    #qrcode canvas {
      display: block;
    }

    .backup-code {
      font-family: monospace;
      font-size: 1.25rem;
      letter-spacing: 0.25rem;
      margin-top: 0.75rem;
      color: var(--cc-gray-dark);
    }

    .qr-refresh {
      font-size: 0.75rem;
      color: var(--cc-gray-dark);
      margin-top: 0.5rem;
    }

    /* Upcoming Events Panel */
    .event-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .event-item {
      display: flex;
      gap: 0.75rem;
      align-items: flex-start;
    }

    .event-time {
      font-weight: 600;
      color: var(--cc-cyan);
      min-width: 60px;
      font-size: 0.9rem;
    }

    .event-details {
      flex: 1;
    }

    .event-title {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .event-room {
      font-size: 0.8rem;
      color: var(--cc-gray-dark);
    }

    /* Trains Panel */
    .train-next {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--cc-gray);
    }

    .train-next-time {
      font-size: 2rem;
      font-weight: 700;
      font-family: var(--font-heading);
      color: var(--cc-cyan);
    }

    .train-next-dest {
      font-size: 0.9rem;
      color: var(--cc-gray-dark);
    }

    .train-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .train-item {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
    }

    .train-item .time { font-weight: 500; }
    .train-item .dest { color: var(--cc-gray-dark); }

    /* Announcements Panel */
    .announcement-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .announcement-item {
      padding: 0.75rem;
      background: var(--cc-gray-light);
      border-radius: 8px;
      border-left: 3px solid var(--cc-cyan);
    }

    .announcement-item.alert {
      border-left-color: var(--cc-gold);
      background: #fffbeb;
    }

    .announcement-title {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
    }

    .announcement-message {
      font-size: 0.85rem;
      color: var(--cc-gray-dark);
    }

    /* Who's Where Panel - Full width bottom */
    .panel-map {
      grid-column: span 2;
    }

    .map-container {
      position: relative;
      width: 100%;
      padding: 20px 0;
    }

    .map-wrapper {
      position: relative;
      width: 100%;
    }

    .map-container svg, .map-container img {
      display: block;
      width: 100%;
      height: auto;
    }

    .room-labels-overlay,
    .people-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    /* Room labels - fixed at top center of each room */
    .room-label {
      position: absolute;
      font-family: var(--font-heading);
      font-weight: 700;
      font-size: clamp(0.9rem, 2vw, 1.5rem);
      color: var(--cc-black);
      background: transparent;
      padding: 0;
      text-align: center;
      line-height: 1.1;
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 5;
    }

    /* Person icons - SVG avatar styling */
    .map-person {
      position: absolute;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .map-person-icon {
      width: clamp(24px, 4vw, 48px);
      height: clamp(21px, 3.5vw, 42px);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.15s ease;
    }

    .map-person-icon:hover {
      transform: scale(1.15);
      z-index: 20;
    }

    .map-person-icon img.person-avatar-svg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* Default cyan color using filter */
      filter: brightness(0) saturate(100%) invert(43%) sepia(98%) saturate(1552%) hue-rotate(176deg) brightness(96%) contrast(101%);
    }

    /* BLE-tracked users: orange */
    .map-person-icon.ble-tracked img.person-avatar-svg {
      filter: brightness(0) saturate(100%) invert(50%) sepia(88%) saturate(2193%) hue-rotate(4deg) brightness(103%) contrast(105%);
    }

    /* Untracked users: gray */
    .map-person-icon.untracked img.person-avatar-svg {
      filter: brightness(0) saturate(100%) invert(40%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(100%) contrast(90%);
      opacity: 0.7;
    }

    .map-person-icon.unknown img.person-avatar-svg {
      filter: brightness(0) saturate(100%) invert(40%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(100%) contrast(90%);
      opacity: 0.5;
    }

    /* Name label below avatar */
    .map-person-name {
      font-family: var(--font-body);
      font-size: clamp(0.5rem, 1.2vw, 0.75rem);
      font-weight: 600;
      color: var(--cc-black);
      white-space: nowrap;
      text-align: center;
      margin-top: 2px;
      text-shadow: 0 0 3px white, 0 0 3px white, 0 0 3px white;
    }

    /* Signal strength indicator dot */
    .signal-indicator {
      position: absolute;
      bottom: 0px;
      right: 0px;
      width: clamp(6px, 1vw, 10px);
      height: clamp(6px, 1vw, 10px);
      border-radius: 50%;
      border: 1.5px solid white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .signal-indicator.strong { background: #22c55e; }
    .signal-indicator.good { background: #eab308; }
    .signal-indicator.weak { background: var(--cc-orange); }
    .signal-indicator.poor { background: #ef4444; }

    .map-room-overlay {
      position: absolute;
      background: rgba(255, 195, 32, 0.8);
      color: var(--cc-black);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .untracked-list {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--cc-gray);
    }

    .untracked-label {
      font-size: 0.75rem;
      color: var(--cc-gray-dark);
      margin-bottom: 0.5rem;
    }

    .untracked-people {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .untracked-person {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
      background: var(--cc-gray-light);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo">Concord <span>Consortium</span></div>
    <div class="time" id="clock">--:--</div>
  </header>

  <div class="alert-banner" id="alert-banner"></div>

  <main class="main-grid">
    <!-- Staff In Office -->
    <section class="panel panel-staff">
      <div class="panel-header">
        <h2>In the Office</h2>
      </div>
      <div class="panel-content">
        <div class="staff-grid" id="staff-grid">
          <div class="empty-state">Loading...</div>
        </div>
      </div>
    </section>

    <!-- Check-in QR Code -->
    <section class="panel panel-checkin">
      <div class="panel-header">
        <h2>Check In!</h2>
      </div>
      <div class="qr-container">
        <div id="qrcode"></div>
        <div class="backup-code" id="backup-code">------</div>
        <div class="qr-refresh" id="qr-refresh">Refreshing...</div>
      </div>
    </section>

    <!-- Upcoming Events -->
    <section class="panel panel-events">
      <div class="panel-header">
        <h2>Upcoming</h2>
      </div>
      <div class="panel-content">
        <div class="event-list" id="event-list">
          <div class="empty-state">No upcoming events</div>
        </div>
      </div>
    </section>

    <!-- Next Trains -->
    <section class="panel panel-trains">
      <div class="panel-header">
        <h2>Next Trains</h2>
      </div>
      <div class="panel-content">
        <div class="train-next" id="train-next">
          <div class="train-next-time">--</div>
          <div class="train-next-dest">Loading...</div>
        </div>
        <div class="train-list" id="train-list"></div>
      </div>
    </section>

    <!-- Announcements -->
    <section class="panel panel-announcements">
      <div class="panel-header">
        <h2>Announcements</h2>
      </div>
      <div class="panel-content">
        <div class="announcement-list" id="announcement-list">
          <div class="empty-state">No announcements</div>
        </div>
      </div>
    </section>

    <!-- Who's Where Map -->
    <section class="panel panel-map">
      <div class="panel-header">
        <h2>Who's Where</h2>
      </div>
      <div class="panel-content">
        <div class="map-container" id="map-container">
          <!-- Office map SVG will be loaded here -->
          <div class="empty-state">Map loading...</div>
        </div>
        <div class="untracked-list" id="untracked-section" style="display: none;">
          <div class="untracked-label">Also in office (location unknown):</div>
          <div class="untracked-people" id="untracked-people"></div>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script>
    const API_BASE = window.location.origin;
    const KIOSK_ID = 'dashboard';

    // =========================================================================
    // Clock
    // =========================================================================
    function updateClock() {
      const now = new Date();
      document.getElementById('clock').textContent =
        now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    setInterval(updateClock, 1000);
    updateClock();

    // =========================================================================
    // Staff Presence
    // =========================================================================
    // Staff avatar mapping (email -> image URL) - loaded from backend
    let STAFF_AVATARS = {};

    async function loadAvatarMappings() {
      try {
        const res = await fetch(`${API_BASE}/api/avatars`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const data = await res.json();
        STAFF_AVATARS = data.mappings || {};
        console.log(`Loaded ${Object.keys(STAFF_AVATARS).length} avatar mappings`);
      } catch (error) {
        console.error('Failed to load avatar mappings:', error);
      }
    }

    function getInitials(name) {
      return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
    }

    function formatArrival(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return `since ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
    }

    async function updatePresence() {
      try {
        const res = await fetch(`${API_BASE}/api/presence`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const data = await res.json();
        // Handle both formats: { users: [...] } and direct array
        const users = data.users || data;
        const present = Array.isArray(users) ? users.filter(p => p.status === 'in') : [];

        const container = document.getElementById('staff-grid');
        if (present.length === 0) {
          container.innerHTML = '<div class="empty-state">No one in the office yet</div>';
          return;
        }

        container.innerHTML = present.map(p => {
          const fullName = p.user_name || p.user_email?.split('@')[0] || 'Unknown';
          const firstName = fullName.split(' ')[0];
          const initials = getInitials(fullName);
          const email = (p.user_email || '').toLowerCase();
          // First check cached avatar, then try avatar_url from user record
          const avatarUrl = STAFF_AVATARS[email] || p.avatar_url;
          const avatarContent = avatarUrl
            ? `<img src="${avatarUrl}" alt="${firstName}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">`
            : '';
          const placeholderStyle = avatarUrl ? 'display:none' : 'display:flex';

          return `
            <div class="staff-card">
              <div class="staff-avatar">
                ${avatarContent}
                <span style="${placeholderStyle}">${initials}</span>
              </div>
              <div class="staff-info">
                <div class="name">${firstName}</div>
                <div class="time">${formatArrival(p.checked_in_at)}</div>
              </div>
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('Presence error:', error);
      }
    }

    // =========================================================================
    // QR Code
    // =========================================================================
    let qrCode = null;
    let qrExpiresAt = null;

    async function refreshQR() {
      try {
        const res = await fetch(`${API_BASE}/api/kiosk/token/${KIOSK_ID}`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        if (!res.ok) throw new Error('Failed to get token');

        const data = await res.json();
        qrExpiresAt = new Date(data.expiresAt);

        const qrUrl = `${window.location.origin}${data.qrData}`;
        const container = document.getElementById('qrcode');
        container.innerHTML = '';

        qrCode = new QRCode(container, {
          text: qrUrl,
          width: 180,
          height: 180,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.M
        });

        document.getElementById('backup-code').textContent =
          data.token.slice(-6).toUpperCase();

        updateQRTimer();
      } catch (error) {
        console.error('QR error:', error);
        document.getElementById('qrcode').innerHTML =
          '<div class="empty-state">Unable to load QR</div>';
      }
    }

    function updateQRTimer() {
      if (!qrExpiresAt) return;
      const remaining = Math.max(0, Math.ceil((qrExpiresAt - Date.now()) / 1000));
      document.getElementById('qr-refresh').textContent = `Refreshes in ${remaining}s`;
    }
    setInterval(updateQRTimer, 1000);

    // =========================================================================
    // Trains
    // =========================================================================
    async function updateTrains() {
      try {
        const res = await fetch(`${API_BASE}/api/trains`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const data = await res.json();

        const nextContainer = document.getElementById('train-next');
        const listContainer = document.getElementById('train-list');

        if (!data.next) {
          nextContainer.innerHTML = `
            <div class="train-next-time">--</div>
            <div class="train-next-dest">No trains scheduled</div>
          `;
          listContainer.innerHTML = '';
          return;
        }

        nextContainer.innerHTML = `
          <div class="train-next-time">${data.nextMinutes}</div>
          <div class="train-next-dest">${data.next.departureTimeFormatted} â†’ ${data.next.destination}</div>
        `;

        // Show remaining trains
        const remaining = data.predictions.slice(1, 5);
        listContainer.innerHTML = remaining.map(t => `
          <div class="train-item">
            <span class="time">${t.departureTimeFormatted}</span>
            <span class="dest">â†’ ${t.destination}</span>
          </div>
        `).join('');
      } catch (error) {
        console.error('Trains error:', error);
      }
    }

    // =========================================================================
    // Announcements
    // =========================================================================
    async function updateAnnouncements() {
      try {
        const res = await fetch(`${API_BASE}/api/announcements`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const data = await res.json();

        // Handle alert banner
        const alertBanner = document.getElementById('alert-banner');
        if (data.alert) {
          alertBanner.textContent = data.alert.title + (data.alert.message ? ': ' + data.alert.message : '');
          alertBanner.classList.add('show');
        } else {
          alertBanner.classList.remove('show');
        }

        // Handle announcements list
        const container = document.getElementById('announcement-list');
        const announcements = data.announcements.filter(a => a.type !== 'alert').slice(0, 4);

        if (announcements.length === 0) {
          container.innerHTML = '<div class="empty-state">No announcements</div>';
          return;
        }

        container.innerHTML = announcements.map(a => `
          <div class="announcement-item ${a.type}">
            <div class="announcement-title">${a.title}</div>
            ${a.message ? `<div class="announcement-message">${a.message}</div>` : ''}
          </div>
        `).join('');
      } catch (error) {
        console.error('Announcements error:', error);
      }
    }

    // =========================================================================
    // Events (Google Calendar integration)
    // =========================================================================
    function formatEventTime(startTime, endTime, isAllDay) {
      if (isAllDay) return 'All day';
      const start = new Date(startTime);
      return start.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    }

    async function updateEvents() {
      try {
        const res = await fetch(`${API_BASE}/api/calendar/events`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const data = await res.json();
        const container = document.getElementById('event-list');

        if (!data.events || data.events.length === 0) {
          container.innerHTML = data.configured
            ? '<div class="empty-state">No upcoming events today</div>'
            : '<div class="empty-state">Calendar integration pending setup</div>';
          return;
        }

        // Show up to 5 events
        const events = data.events.slice(0, 5);
        container.innerHTML = events.map(event => `
          <div class="event-item">
            <div class="event-time">${formatEventTime(event.startTime, event.endTime, event.isAllDay)}</div>
            <div class="event-details">
              <div class="event-title">${event.title}</div>
              <div class="event-room">${event.room}</div>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Events error:', error);
        document.getElementById('event-list').innerHTML =
          '<div class="empty-state">Unable to load events</div>';
      }
    }

    // =========================================================================
    // Who's Where Map
    // =========================================================================
    let mapLoaded = false;

    // Room definitions with label positions (% of SVG dimensions)
    // label_x, label_y: position for room label at top-center of room
    // center_x, center_y: center point for placing people (below labels)
    const ROOM_CONFIG = {
      museum:       { label: 'Museum',              label_x: 8,   label_y: 5,   center_x: 8,   center_y: 20 },
      cafe:         { label: 'CafÃ©',                label_x: 31,  label_y: 5,   center_x: 31,  center_y: 20 },
      shop:         { label: 'Shop',                label_x: 92,  label_y: 5,   center_x: 92,  center_y: 20 },
      entry:        { label: 'Entry',               label_x: 5,   label_y: 45,  center_x: 5,   center_y: 55 },
      bubble:       { label: 'Bubble<br>Room',      label_x: 62,  label_y: 68,  center_x: 62,  center_y: 90 },
      aviary:       { label: 'Aviary',              label_x: 72,  label_y: 72,  center_x: 72,  center_y: 85 },
      wonder:       { label: 'Wonder<br>Room',      label_x: 83,  label_y: 50,  center_x: 83,  center_y: 72 },
      workstations: { label: 'Work<br>Stations',    label_x: 92,  label_y: 50,  center_x: 92,  center_y: 72 }
    };

    async function loadMap() {
      const mapContainer = document.getElementById('map-container');

      try {
        // Load the office map SVG
        const res = await fetch(`${API_BASE}/office-map.svg`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const svgText = await res.text();

        // Generate room labels HTML
        const roomLabelsHtml = Object.entries(ROOM_CONFIG).map(([id, room]) => `
          <div class="room-label" style="left: ${room.label_x}%; top: ${room.label_y}%;">${room.label}</div>
        `).join('');

        mapContainer.innerHTML = `
          <div class="map-wrapper" style="position: relative;">
            ${svgText}
            <div class="room-labels-overlay" id="room-labels-overlay">${roomLabelsHtml}</div>
            <div class="people-overlay" id="people-overlay"></div>
          </div>
        `;

        // Style the SVG to fill width and maintain aspect ratio
        const svg = mapContainer.querySelector('svg');
        if (svg) {
          svg.style.width = '100%';
          svg.style.height = 'auto';
        }

        mapLoaded = true;
        await updateMapPeople();
      } catch (error) {
        console.error('Map error:', error);
        mapContainer.innerHTML = `
          <div class="empty-state" style="text-align: center; padding: 2rem;">
            <div style="font-size: 0.9rem; margin-bottom: 0.5rem;">Office Map</div>
            <div style="font-size: 0.75rem; color: var(--cc-gray-dark);">
              Unable to load map
            </div>
          </div>
        `;
      }
    }

    /**
     * Get signal strength class based on certainty (0-1)
     * Used for BLE-tracked users to show signal quality
     */
    function getSignalStrengthClass(certainty) {
      if (certainty >= 0.8) return 'strong';
      if (certainty >= 0.6) return 'good';
      if (certainty >= 0.4) return 'weak';
      return 'poor';
    }

    async function updateMapPeople() {
      if (!mapLoaded) return;

      try {
        const res = await fetch(`${API_BASE}/api/map/people`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
        const data = await res.json();

        const overlay = document.getElementById('people-overlay');
        const untrackedSection = document.getElementById('untracked-section');
        const untrackedPeople = document.getElementById('untracked-people');

        if (!overlay) return;

        // Group people by room for distribution
        const roomGroups = {};
        data.located.forEach(person => {
          const roomId = person.room_id || 'unknown';
          if (!roomGroups[roomId]) roomGroups[roomId] = [];
          roomGroups[roomId].push(person);
        });

        // Calculate positions with distribution for multiple people per room
        const peopleHtml = [];
        Object.entries(roomGroups).forEach(([roomId, people]) => {
          const roomConfig = ROOM_CONFIG[roomId];

          people.forEach((person, index) => {
            const name = person.user_name || person.user_email?.split('@')[0] || '?';
            const initials = name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
            const email = (person.user_email || '').toLowerCase();
            const avatarUrl = STAFF_AVATARS[email] || person.avatar_url;

            // Use ROOM_CONFIG positions if available, with distribution offset
            let posX, posY;
            if (roomConfig) {
              // Distribute people in a grid pattern around room center
              const cols = Math.ceil(Math.sqrt(people.length));
              const row = Math.floor(index / cols);
              const col = index % cols;
              const spacing = 4; // % spacing between people
              const offsetX = (col - (cols - 1) / 2) * spacing;
              const offsetY = row * spacing;
              posX = roomConfig.center_x + offsetX;
              posY = roomConfig.center_y + offsetY;
            } else {
              // Fallback to server-provided position
              posX = person.position.x;
              posY = person.position.y;
            }

            // Determine tracking status and icon class
            const isTracked = person.is_tracked === true;
            const iconClass = isTracked ? 'ble-tracked' : 'untracked';

            // Calculate opacity based on signal certainty
            const certainty = person.signal_certainty || 0;
            const opacity = isTracked ? Math.max(0.5, certainty) : 1;

            // Get signal strength indicator class
            const signalClass = isTracked ? getSignalStrengthClass(certainty) : '';

            // Get first name only for label
            const firstName = name.split(' ')[0];

            peopleHtml.push(`
              <div class="map-person" style="left: ${posX}%; top: ${posY}%; opacity: ${opacity};">
                <div class="map-person-icon ${iconClass}">
                  <img src="/person-map-avatar.svg" alt="${name}" class="person-avatar-svg">
                  ${isTracked ? `<div class="signal-indicator ${signalClass}"></div>` : ''}
                </div>
                <div class="map-person-name">${firstName}</div>
              </div>
            `);
          });
        });

        overlay.innerHTML = peopleHtml.join('');

        // Render unlocated people in the list below
        if (data.unlocated.length > 0) {
          untrackedSection.style.display = 'block';
          untrackedPeople.innerHTML = data.unlocated.map(person => {
            const name = person.user_name || person.user_email?.split('@')[0] || 'Unknown';
            const isTracked = person.is_tracked === true;
            const beaconIndicator = isTracked ? ' ðŸ“¡' : '';
            return `<span class="untracked-person">${name}${beaconIndicator}</span>`;
          }).join('');
        } else {
          untrackedSection.style.display = 'none';
        }
      } catch (error) {
        console.error('Map people error:', error);
      }
    }

    // =========================================================================
    // Server-Sent Events for Real-Time Updates
    // =========================================================================
    let eventSource = null;

    function connectSSE() {
      if (eventSource) {
        eventSource.close();
      }

      eventSource = new EventSource(`${API_BASE}/api/events`);

      eventSource.addEventListener('checkin', (event) => {
        console.log('SSE: checkin event received');
        // Immediately update presence and map
        updatePresence();
        updateMapPeople();
      });

      eventSource.addEventListener('checkout', (event) => {
        console.log('SSE: checkout event received');
        // Immediately update presence and map
        updatePresence();
        updateMapPeople();
      });

      eventSource.addEventListener('connected', (event) => {
        console.log('SSE connected:', event.data);
      });

      eventSource.addEventListener('error', (event) => {
        console.error('SSE error, reconnecting in 5s...', event);
        eventSource.close();
        setTimeout(connectSSE, 5000);
      });
    }

    // =========================================================================
    // Initialize
    // =========================================================================
    async function initialize() {
      // Load avatar mappings first
      await loadAvatarMappings();

      // Then load all data
      updatePresence();
      refreshQR();
      updateTrains();
      updateAnnouncements();
      updateEvents();
      loadMap();

      // Connect to SSE for real-time updates
      connectSSE();
    }

    initialize();

    // Refresh intervals (SSE will handle presence updates immediately, but keep polling as fallback)
    setInterval(updatePresence, 30000);          // 30 seconds (reduced, SSE handles most updates)
    setInterval(refreshQR, 30000);               // 30 seconds
    setInterval(updateTrains, 60000);            // 1 minute
    setInterval(updateAnnouncements, 30000);     // 30 seconds
    setInterval(updateEvents, 60000);            // 1 minute
    setInterval(loadAvatarMappings, 300000);     // 5 minutes - reload avatar mappings
    setInterval(updateMapPeople, 30000);         // 30 seconds (reduced, SSE handles most updates)
  </script>
</body>
</html>
